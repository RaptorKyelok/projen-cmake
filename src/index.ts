/**
 * projen-cmake
 *
 * Author: Kyelok
 */

import { Project, ProjectOptions, TextFile } from 'projen';
import { ProjenrcTs } from 'projen/lib/typescript';
import { validator } from './validation';

export class CMakeFileFragment {
  dependsOn: CMakeFileFragment[] = [];
  prefixLines: string[] = [];
  postfixLines: string[] = [];
}

export class CMakeTarget extends CMakeFileFragment {
  name: string;
  declarationNumber: number;
  project: CMakeProject;
  targetLibraries: CMakeLibrary[] = [];

  constructor(project: CMakeProject, name: string, declaration_number: number) {
    super();
    this.project = project;
    this.name = name;
    this.declarationNumber = declaration_number;
  }
}

export class CMakeExecutable extends CMakeTarget {
  filenames: string[] = [];

  constructor(project: CMakeProject, name: string, declaration_number: number) {
    super(project, name, declaration_number);
  }

  synth(cmakefile: TextFile): void {
    const addexe_str = `add_executable(${this.name}`;
    // Deal with the no-files case
    if (this.filenames.length == 0) {
      validator.warn(`Executable '${this.name}' has no attached source files`);
      cmakefile.addLine(`${addexe_str})`);
      cmakefile.addLine('');
      return;
    }

    // Add given files to the executable definition
    cmakefile.addLine(`${addexe_str} ${this.filenames[0]}`);
    const padding = ' '.repeat(addexe_str.length);
    for (let filename of this.filenames.slice(1)) {
      cmakefile.addLine(`${padding} ${filename}`);
    }
    cmakefile.addLine('');
  }
}

export class CMakeLibrary extends CMakeTarget {
  filenames: string[] = [];

  constructor(project: CMakeProject, name: string, declaration_number: number) {
    super(project, name, declaration_number);
  }

  addSourceFile(filename: string): CMakeLibrary {
    this.filenames.push(filename);
    return this;
  }

  synth(cmakefile: TextFile): void {
    const addlib_str = `add_library(${this.name}`;
    // Deal with the no-files case
    if (this.filenames.length == 0) {
      validator.warn(`Library '${this.name}' has no attached source files`);
      cmakefile.addLine(`${addlib_str})`);
      cmakefile.addLine('');
      return;
    }

    // Add given files to the executable definition
    cmakefile.addLine(`${addlib_str} ${this.filenames[0]}`);
    const padding = ' '.repeat(addlib_str.length);
    for (let filename of this.filenames.slice(1)) {
      cmakefile.addLine(`${padding} ${filename}`);
    }
    cmakefile.addLine('');
  }
}

export class CMakePackage {
  name: string;
  declarationNumber: number;
  project: CMakeProject;

  constructor(project: CMakeProject, name: string, declaration_number: number) {
    this.project = project;
    this.name = name;
    this.declarationNumber = declaration_number;
  }
}

export interface CMakeProjectOptions extends ProjectOptions {
  /**
   * The version of CMake that CMakeLists.txt should specify
   * @default 3.5
   */
  readonly cmakeMinVersion?: number;
}

export class CMakeProject extends Project {
  private _cmakefile: TextFile;

  private _executables: CMakeExecutable[] = [];
  private _libraries: CMakeLibrary[] = [];
  private _packages: CMakePackage[] = [];

  private _declarationCounter: number = 1;

  readonly defaultCMakeMinVersion: number = 3.5;

  constructor(options: CMakeProjectOptions) {
    super(options);

    new ProjenrcTs(this);

    this.defaultTask?.exec('ts-node .projenrc.ts');

    this._cmakefile = new TextFile(this, './CMakeLists.txt', { marker: false, readonly: true });
    this._cmakefile.addLine('# ~~ This file was auto-generated by Projen.');
    this._cmakefile.addLine('# ~~ To make changes, please edit .projenrc.ts and run `npx projen` to rebuild.');
    this._cmakefile.addLine('');
    this._cmakefile.addLine(`cmake_minimum_required(VERSION ${options.cmakeMinVersion ?? this.defaultCMakeMinVersion})`);
    this._cmakefile.addLine('');
  }

  declareExecutable(name: string): CMakeExecutable {
    const exe = new CMakeExecutable(this, name, this._declarationCounter);
    this._declarationCounter++;
    this._executables.push(exe);
    return exe;
  }

  declareLibrary(name: string): CMakeExecutable {
    const lib = new CMakeLibrary(this, name, this._declarationCounter);
    this._declarationCounter++;
    this._libraries.push(lib);
    return lib;
  }

  findPackage(package_name: string): CMakePackage {
    const cmake_package = new CMakePackage(this, package_name, this._declarationCounter);
    this._declarationCounter++;
    this._packages.push(cmake_package);
    return cmake_package;
  }

  preSynthesize(): void {
    // TODO: attach pre and post lines to each synthesized part
    for (let executable of this._executables) {
      executable.synth(this._cmakefile);
    }
    for (let library of this._libraries) {
      library.synth(this._cmakefile);
    }
    // Add find_package statements as needed
  }

  postSynthesize(): void {
    console.log(`Warnings: ${validator.num_warns}`);
  }
}
